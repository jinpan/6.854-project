\section{Experimental Results}

We have implemented Garg-MCF in the Python programming language and
have tested it upon a variety of problems. Due to the automatic
garbage collection of Python, clock time of the implementation should
be taken with a grain of salt. Instead, we measure the number of calls
to the single-source shortest path subroutine. Since we make one call
per step this serves as a valid measurement of runtime. We first
describe the construction of random graphs. \\
We construct random directed graphs using the networkx module's
$\mathrm{gnm\_random\_graph}$ routine, feeding parameters of $n$ and
$m$ \cite{networkx}. Then we randomly create commodities by a grouping
procedure. We take the number of commodities as a parameter and a
distribution which defines the number of shared source commodities we
have, randomly choosing sinks for the commodities, ensuring that there
exists a directed path from the source to the sink for each
commodity. Capacities and demands are chosen randomly. This set of
procedures allows us to randomly generate a directed graph with a
given number of nodes, edges, commodities, and we can explicitly specify the
number of commodity groups. With this in hand, we can proceed to test
the algorithm's dependence on $\omega$ and $k$, taking note of the
effect of Karakosta's heuristic for shared source commodities.
\subsection{Dependence on the parameter $\omega$}

\subsection{Dependence on the parameter $k$}.

