
\SetAlgoSkip{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[h!] \small \label{obiRRT}
$V \leftarrow \{ x_\mathrm{init}, x_\mathrm{goal}\}$; $E \leftarrow \emptyset$\; 
$T_{a} \leftarrow (x_\mathrm{init},E)$; $T_{b} \leftarrow (x_\mathrm{goal},E)$\;
$c_{best} \leftarrow \infty; \sigma_\mathrm{best} \leftarrow \emptyset$\; \label{line:rrtstar:initialize}
\For{ $i = 1$ to $N$}{\label{line:rrtstar:iteration_start}
  $x_\mathrm{rand} \leftarrow {\tt Sample}$\; 
  $x_\mathrm{nearest} \leftarrow {\tt Nearest} (T_{a}, x_\mathrm{rand})$\;
  $x_\mathrm{new} \leftarrow {\tt Extend}(x_\mathrm{nearest}, x_\mathrm{rand})$\;
  $X_\mathrm{near} \leftarrow {\tt Near} (T_{a}, x_\mathrm{new})$\;
  $x_\mathrm{min}\leftarrow \tt{Argmin}\{{\tt Cost}(T_a,x_i)+\delta(x_i,x_{near})| x_i\in V; CollisionFree((x_i,x_{near})\}$\;
  $V \leftarrow V \cup ( x_\mathrm{new} )$\;
  $E \leftarrow E \cup (\, (x_\mathrm{min}, x_\mathrm{new}) \, )$\;
  \For{$x_\mathrm{near} \in X_\mathrm{near}$}{ \label{rewire}
                \If{${\tt Cost}(T_a,x_\mathrm{new}) + \delta{x_\mathrm{near},x_\mathrm{new}} < {\tt Cost}(T_a,x_\mathrm{near})$}{ 
                          \If{${\tt CollisionFree}(x_\mathrm{near},x_\mathrm{new})$}{
                                  $x_\mathrm{oldparent} \leftarrow {\tt Parent}(E, x_\mathrm{near})$\;
                                  $E \leftarrow E \backslash (\, (x_\mathrm{oldparent}, x_\mathrm{near})\,)$\;
                                  $E \leftarrow E \cup (\,(x_\mathrm{new}, x_\mathrm{near})\,)$\;
                          }
                  }
        }

        $x_\mathrm{connect} \leftarrow {\tt Nearest} (T_{b}, x_\mathrm{new})$\;
  $(c_\mathrm{sol}, \sigma_\mathrm{sol}) \leftarrow {\tt ConnectGraphs}(T_{b}, x_\mathrm{connect}, x_\mathrm{new})$\;
                          \If{$c_\mathrm{sol} < c_\mathrm{best}$}{
                          $c_\mathrm{best} \leftarrow c_\mathrm{sol}$\;
                          $\sigma_\mathrm{best} \leftarrow \sigma_\mathrm{sol}$\;
                          }
        ${\tt SwapTrees}(T_{a},T_{b})$\;
}
\Return{ $T_{a},T_{b} = (V,E)$.}
\caption{OBiRRT without heuristics $(x_\mathrm{init}, x_\mathrm{goal})$}
\end{algorithm}

\begin{algorithm}[h!] \small
$x_\mathrm{new} \leftarrow {\tt Extend}(x_\mathrm{i}, x_\mathrm{f})$\;
$X_\mathrm{near} \leftarrow {\tt Near} (T_{b}, x_\mathrm{new})$\;
$x_\mathrm{connect} \leftarrow {\tt argmin}\{{\tt Cost}(T_b,x_p)+\delta(x_\mathrm{p},x_\mathrm{f})|x_p\in X_\mathrm{near}; {\tt CollisionFree}((x_\mathrm{p},x_\mathrm{f}) \}$\;
\If{$x_\mathrm{connect}\neq {\tt NULL}$}{
$E \leftarrow E \cup ((x_\mathrm{near}, x_\mathrm{connect}))$\;
$\sigma_\mathrm{connect} \leftarrow {\tt GeneratePath}(x_\mathrm{near}, x_\mathrm{connect})$\;

\Return $(c_\mathrm{near}, \sigma_\mathrm{connect})$\;
}
                
        

\Return {{\tt NULL}}
\caption{${\tt ConnectGraphs}(T_{b}, x_\mathrm{i}, x_\mathrm{f})$}
\end{algorithm}
%
% Restore default vertical spacing
\SetAlgoSkip{smallskip}
